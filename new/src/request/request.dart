import 'dart:convert';
import 'dart:io';
import 'dart:math';
import 'dart:typed_data';

import 'package:crypto/crypto.dart';
import 'package:logging/logging.dart';
import 'package:routingkit/routingkit.dart';

import '../application.dart';
import '../http/headers/cookies.dart';
import '../http/headers/http_headers.dart';
import '../routing/route.dart';
import '../utilities/storage.dart';
import '../utilities/uri.dart';
import '../utilities/url_search_params.dart';

/// Represents an HTTP request in an application.
class Request {
  /// Returns current request application.
  final Application application;

  /// A unique ID for the request.
  ///
  /// This ID is unique for each request and is generated by the application.
  late final String id;

  /// current request local storage.
  late Storage storage;

  /// Current request logger.
  late Logger logger;

  /// The HTTP method for the request.
  String get method => _box.method;

  /// The URL used on this request.
  URI get url => _box.requestedUri;

  /// The version for this HTTP request.
  String get version => _box.protocolVersion;

  /// The header fields for this HTTP request.
  HTTPHeaders get headers => _box.headers;

  /// Route object we found for this request.
  Route? route;

  /// We try to determine true peer address if load balancer or reversed proxy
  /// provided info in headers
  ///
  /// Priority of getting value from headers is as following:
  ///
  /// 1. try the "Forwarded" header (e.g. for=192.0.2.60; proto=http; by=203.0.113.43)
  /// 2. try the "X-Forwarded-For" header (e.g. client_IP, proxy1_IP, proxy2_IP)
  /// 3. fallback to the socket's remote address provided by dart:io ( e.g. 192.
  /// 0.2.60:62934)
  /// in 1. and 2. will use port 80 as default port, and  3. will have port
  /// number provided by NIO if any
  InternetAddress? get peerAddress {
    final forwarded = headers.value('forwarded');
    if (forwarded != null) {
      final parts = forwarded.split(';');
      for (final part in parts) {
        final pair = part.split('=');
        if (pair.length == 2 && pair[0].trim().toLowerCase() == 'for') {
          final address = pair[1].trim().split(',').first;
          return InternetAddress(address);
        }
      }
    }

    final xForwardedFor = headers.value('x-forwarded-for');
    if (xForwardedFor != null) {
      final address = xForwardedFor.split(',').first;
      return InternetAddress(address.trim());
    }

    return remoteAddress;
  }

  InternetAddress? get remoteAddress => _box.connectionInfo?.remoteAddress;

  /// HTTP url search params.
  URLSearchParams get query {
    final existing = storage.get(const StorageKey<URLSearchParams>());
    if (existing != null) return existing;

    return storage.set(
      const StorageKey<URLSearchParams>(),
      URLSearchParams(_box.uri.queryParametersAll),
    );
  }

  /// content type
  ContentType? get contentType => headers.contentType;

  /// Cookies sent with the request.
  Cookies get cookies {
    final existing = storage.get(const StorageKey<Cookies>());
    if (existing != null) return existing;

    return storage.set(
      const StorageKey<Cookies>(),
      Cookies(_box.cookies, _box.response.cookies),
    );
  }

  /// A container containing the route parameters that were captured when
  /// receiving this request.
  ///
  /// Use this container to grab any non-static parameters from the URL, such
  /// as model IDs in a REST API.
  Parameters get parameters {
    final existing = storage.get(const StorageKey<Parameters>());
    if (existing != null) return existing;

    return storage.set(
      const StorageKey<Parameters>(),
      Parameters(),
    );
  }

  /// The body stream of the request.
  Stream<Uint8List> stream() {
    final existing = storage.get(const StorageKey<Stream<Uint8List>>());
    if (existing != null) return existing;

    return storage.set(
      const StorageKey<Stream<Uint8List>>(),
      switch (_box) {
        HttpRequest request when request.isBroadcast => request,
        HttpRequest request => request.asBroadcastStream(),
      },
    );
  }

  /// the body as string
  Future<String> text([Encoding encoding = utf8]) {
    return encoding.decodeStream(stream());
  }

  @override
  String toString() {
    final buffer = StringBuffer("HTTP $method $url");
    buffer.writeln(headers.toDebugString());
    buffer.writeln('Body: ...${headers.contentLength}');

    return buffer.toString();
  }

  /// Returns the request debug string.
  Future<String> toDebugString() async {
    final buffer = StringBuffer("HTTP $method $url");
    buffer.writeln(headers.toDebugString());

    try {
      buffer.writeln(await text());
    } catch (e) {
      buffer.writeln('Error reading body: $e');
    }

    return buffer.toString();
  }

  /// Internal request box.
  late final HttpRequest _box;

  Request({
    required this.application,
    required HttpRequest request,
    Logger? logger,
  }) {
    _box = request;
    id = request.headers.value('x-request-id') ?? generateId();
    this.logger = logger ?? Logger.detached('spry.request.[$id]');
    storage = Storage();

    storage.set(const StorageKey<HttpRequest>(), request);
  }
}

extension on Request {
  /// Generates a new request id.
  String generateId() {
    final random = Random.secure();
    final bytes = List<int>.generate(128, (_) => random.nextInt(256));

    return sha256.convert(bytes).toString();
  }
}
